import { HierarchieComplete } from '../../shared/types';

interface StructureNode {\n  code: string;\n  nom: string;\n  niveau: number;\n  parent?: StructureNode;\n  children: StructureNode[];\n}\n\nexport class StructureParser {\n  private static instance: StructureParser;\n  private structureMap: Map<string, StructureNode> = new Map();\n  private initialized = false;\n\n  public static getInstance(): StructureParser {\n    if (!StructureParser.instance) {\n      StructureParser.instance = new StructureParser();\n    }\n    return StructureParser.instance;\n  }\n\n  public initializeStructure(structureText: string): void {\n    if (this.initialized) return;\n    \n    const lines = structureText.split('\\n').filter(line => line.trim());\n    const nodeStack: StructureNode[] = [];\n    \n    for (const line of lines) {\n      if (line.includes('Structure CYRUS') || line.includes('201 GEANT CASINO')) {\n        continue;\n      }\n      \n      const trimmedLine = line.trim();\n      if (!trimmedLine) continue;\n      \n      // Calculer le niveau d'indentation\n      const indentation = line.length - line.trimStart().length;\n      const niveau = Math.floor(indentation / 2) + 1;\n      \n      // Extraire le code et le nom\n      const match = trimmedLine.match(/^(\\d+)\\s+(.+)$/);\n      if (!match) continue;\n      \n      const [, code, nom] = match;\n      \n      // Créer le noeud\n      const node: StructureNode = {\n        code,\n        nom: nom.trim(),\n        niveau,\n        children: []\n      };\n      \n      // Gérer la hiérarchie\n      while (nodeStack.length > 0 && nodeStack[nodeStack.length - 1].niveau >= niveau) {\n        nodeStack.pop();\n      }\n      \n      if (nodeStack.length > 0) {\n        const parent = nodeStack[nodeStack.length - 1];\n        node.parent = parent;\n        parent.children.push(node);\n      }\n      \n      nodeStack.push(node);\n      this.structureMap.set(code, node);\n    }\n    \n    this.initialized = true;\n  }\n\n  public findHierarchie(codeRecherche: string): HierarchieComplete | null {\n    const node = this.structureMap.get(codeRecherche);\n    if (!node) {\n      // Essayer de trouver par correspondance partielle\n      for (const [code, nodeItem] of this.structureMap) {\n        if (code.includes(codeRecherche) || codeRecherche.includes(code)) {\n          return this.buildHierarchie(nodeItem);\n        }\n      }\n      return null;\n    }\n    \n    return this.buildHierarchie(node);\n  }\n\n  private buildHierarchie(node: StructureNode): HierarchieComplete {\n    // Remonter la hiérarchie pour trouver tous les niveaux\n    const hierarchy: StructureNode[] = [];\n    let current: StructureNode | undefined = node;\n    \n    while (current) {\n      hierarchy.unshift(current);\n      current = current.parent;\n    }\n    \n    // Assurer qu'on a 4 niveaux (remplir avec des valeurs par défaut si nécessaire)\n    while (hierarchy.length < 4) {\n      hierarchy.push({\n        code: '999',\n        nom: 'NON DEFINI',\n        niveau: hierarchy.length + 1,\n        children: []\n      });\n    }\n    \n    return {\n      secteur: {\n        code: hierarchy[0]?.code || '99',\n        nom: hierarchy[0]?.nom || 'SECTEUR NON DEFINI'\n      },\n      rayon: {\n        code: hierarchy[1]?.code || '999',\n        nom: hierarchy[1]?.nom || 'RAYON NON DEFINI'\n      },\n      famille: {\n        code: hierarchy[2]?.code || '999',\n        nom: hierarchy[2]?.nom || 'FAMILLE NON DEFINIE'\n      },\n      sousFamille: {\n        code: hierarchy[3]?.code || '999',\n        nom: hierarchy[3]?.nom || 'SOUS-FAMILLE NON DEFINIE'\n      }\n    };\n  }\n\n  public findByLibelle(libelle: string): HierarchieComplete | null {\n    const libelleLower = libelle.toLowerCase();\n    \n    // Recherche par mots-clés dans le libellé\n    for (const [code, node] of this.structureMap) {\n      const nomLower = node.nom.toLowerCase();\n      \n      // Recherche exacte\n      if (nomLower.includes(libelleLower) || libelleLower.includes(nomLower)) {\n        return this.buildHierarchie(node);\n      }\n      \n      // Recherche par mots-clés\n      const mots = libelleLower.split(/\\s+/);\n      const motNode = nomLower.split(/\\s+/);\n      \n      let score = 0;\n      for (const mot of mots) {\n        if (mot.length > 2) { // Ignorer les mots trop courts\n          for (const motN of motNode) {\n            if (motN.includes(mot) || mot.includes(motN)) {\n              score++;\n            }\n          }\n        }\n      }\n      \n      if (score >= 2) {\n        return this.buildHierarchie(node);\n      }\n    }\n    \n    return null;\n  }\n\n  public getAllSecteurs(): Array<{code: string, nom: string}> {\n    const secteurs: Array<{code: string, nom: string}> = [];\n    \n    for (const [code, node] of this.structureMap) {\n      if (node.niveau === 1) {\n        secteurs.push({ code, nom: node.nom });\n      }\n    }\n    \n    return secteurs.sort((a, b) => a.code.localeCompare(b.code));\n  }\n\n  public getRayonsBySecteur(secteurCode: string): Array<{code: string, nom: string}> {\n    const secteur = this.structureMap.get(secteurCode);\n    if (!secteur) return [];\n    \n    return secteur.children.map(child => ({\n      code: child.code,\n      nom: child.nom\n    }));\n  }\n\n  public getFamillesByRayon(rayonCode: string): Array<{code: string, nom: string}> {\n    const rayon = this.structureMap.get(rayonCode);\n    if (!rayon) return [];\n    \n    return rayon.children.map(child => ({\n      code: child.code,\n      nom: child.nom\n    }));\n  }\n\n  public getSousFamillesByFamille(familleCode: string): Array<{code: string, nom: string}> {\n    const famille = this.structureMap.get(familleCode);\n    if (!famille) return [];\n    \n    return famille.children.map(child => ({\n      code: child.code,\n      nom: child.nom\n    }));\n  }\n}